1.JNI是一套标准的的接口，JVM必须实现JNI接口以提供本地(C/C++)应用与JVM互相调用，因此一个运行在JVM上面的JAVA项目可以集成一个C/C++库或本地(C/C++)应用，也可以把整个JVM嵌入到C/C++项目
中。由于JNI是标准的接口，因此JNI代码具有可移植性，但作为交互的C/C++库或本地(C/C++)应用本身不跨平台。


2.Java平台(Java Platform)的组成：Java VM和Java API。任何组织实现的Java平台都要支持：Java编程语言，虚拟机，和API。JVM上运行的都是与平台无关的字节码(.class文件)。JRE是一个Java平台，
实现了JVM以及Java API,而JDK是Java的应用的开发工具，提供了编译器，调试器和其他工具等等。Java API对于JVM来说是.class文件，对于JDK来说是.java文件。


3.本地平台环境：操作系统，一组本机库，和CPU指令集。本地(C/C++)应用：通常依赖于一个特定的平台环境, 用 C、C++等语言开发，并被编译成平台相关的二进制指令。JVM除了以JNI的方式通过C/C++库
或本地(C/C++)应用与本地平台环境进行交互，本身也实现了直接与本地平台环境进行交互。


4.JNI编程的一般性原则：做好应用程序架构，使native methods定义在尽可能少的几个类里。减少移植工作消耗的成本。


5.使用JNI带来的问题：
	1.脱离JAVA以后带来的移植性问题，且跨平台时需要重新编译链接本地库。
	2.引入C/C++本身的语言性问题，比如内存泄漏、数组越界，会直接带来应用程序的崩溃。
	3.JAVA语言的封装性被破坏，任何方法和属性，无论是pulbic还是private/protected/package的，对JNI来说都是可见的(相当于反射)。
	4.对LocalRef/GlobalRef管理不善，会引发Table Overflow Exception，导致应用崩溃。


6.使用JNI带来的好处：
	1.可以直接使用许多现成的高效的本地库。
	2.可以重写JAVA中的低效方法和低效实现。
	3.避免跨进程带来的低效数据拷贝，既耗时又耗内存。



7.IPC或者通过TCP/IP网络方案(Android Binder or Android ASE)可以成为替换JNI与本地代码交互的另外一种方案，与JNI不同的地方在于Java程序与本地代码驻留在不同的进程，这样做最大的好处在于一个进程的
崩溃，不会立即影响到另一个进程。但是跨进程的缺点主要在于进程间通讯的耗时，进程间低效的数据拷贝操作，以及多进程的派生既耗费时间又耗费资源(内存)。方案的取舍决定于代码本身需要实现的功能。